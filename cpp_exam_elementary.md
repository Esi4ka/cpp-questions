# Elementary (теормин)

# Useful notes

- недопустимо существование двух функций, которые отличаются лишь типом возвращаемого значения

- return в конструкторе - не CE
- после try обязательно catch
- upper_bound in map: returns an iterator pointing to the first element in the container whose key is considered to go after *k*.
- lower_bound in map: returns an iterator pointing to the first element that is *not less* than key (key может не быть в map, тогда найдем по сути upper_bound)
- 0.0 в cout как 0

## 1-2

**Интерпретатор** построчно читает исходный код программы и выполняет инструкции,  содержащиеся в текущей строке, потом переходит к следующей строке. **Компилятор** читает всю программу и преобразует ее в объектный код, который является такой формой кода, которая может напрямую выполняться компьютером.

**CE**

Ошибка времени компиляции возникает, когда код написан некорректно с точки зрения языка. Из такого кода не получается создать исполняемый файл. 

1) 24abracadabra — лексическая ошибка

2) int const = 5; — синтаксическая ошибка

3) foo(3), хотя сигнатура foo — void foo(int a, int b) — семантическая ошибка

**RE**

Программа компилируется корректно, но в ходе выполнения она делает что-то непотребное (смотри примеры). RE невозможно отследить на этапе компиляции (компилятор может разве что кинуть предупреждение в месте потенциальной ошибки)

1) Слишком большая глубина рекурсии — получаем stack overflow

2) При попытке записи в невыделенную память операционная система аварийно завершает программу — получаем segmentation fault

3) Деление на ноль

4) Исключение, которое никто не поймал - RE

**UB** **- undefined behaviour**

UB возникает при выполнении кода, результат исполнения которого не описан в стандарте. В случае UB компилятор волен сделать, всё что угодно. UB может переродиться в CE, RE, или пройти незамеченным и нормально отработать.

The behavior of the program varies between implementations, and the  conforming implementation is not required to document the effects of  each behavior.

1) Для static_cast преобразование указателя на родительский класс к указателю на дочерний класс. Объект по указателю обязан быть правильного дочернего класса, иначе это undefined behaviour.

2) ++x = x++;— порядок вычисления аргументов оператора не определён. (until C++17)

3) Чтение выделенной, но неинициализированной памяти. В теории, считается какой-то мусор.

4) Выход за границы C-style массива.

5) Отсутствие return в конце функции, которая что-то возвращает. UB, не CE.

## 3

char - Переменная типа char занимает 1 байт. Однако вместо конвертации значения типа char в целое число, оно *интерпретируется* как ASCII-символ.

a [`double`](http://en.wikipedia.org/wiki/Double_precision_floating-point_format) has 2x the precision of [`float`](http://en.wikipedia.org/wiki/Single_precision_floating-point_format)

## 4

Оператор «запятая» используется для связки нескольких выражений. Значение выражения, находящегося с правой стороны, станет значением разделенного запятыми выражения.  Например:

 х = (у = 3, у + 1);

 Сначала присваивается 3 переменной у, а затем 4. переменной х. Скобки  необходимы, поскольку оператор «запятая» имеет более низкий приоритет по сравнению с оператором присваивания.

## 6

При объявлении переменной, функции или даже класса все, что вы делаете,  это говорите компилятору, что есть что-то с определенным именем и  определенного типа. Компилятор может обрабатывать большинство (но не  все) использований этого имени, без необходимости полного определения  этого имени.

Определение чего-то означает предоставление всей необходимой информации  для создания сущности целиком. Например, определение функции означает предоставление тела функции, определение класса означает предоставление всех методов и  полей класса. 

```cpp
int func(); // объявление
int func() { return 2; } // определение

class MyClass; // объявление
class MyClass { int field; } // определение

int x; // объявление
x = 3; // определение

using identifier = int;
```

**Правило одного определения (ODR)**. Назначение ODR состоит в том, чтобы в программе не могло появиться два  или более конфликтующих между собой определения одной и той же сущности ([типа данных](https://ru.wikipedia.org/wiki/Тип_данных), [переменной](https://ru.wikipedia.org/wiki/Переменная_(программирование)), [функции](https://ru.wikipedia.org/wiki/Функция_(программирование))). Если это правило соблюдено, программа ведёт себя так, как будто в ней  существует только одно, общее определение любой сущности. Нарушение ODR, если оно не будет обнаружено при [компиляции](https://ru.wikipedia.org/wiki/Компиляция_(программирование)) и [сборке](https://ru.wikipedia.org/wiki/Компоновщик) проекта, приводит к UB.

## 7

**Стековая память** — память, в которой находятся все локальные переменные функций. Её у нас условно где-то несколько мегабайт

**Динамическая память** — некоторая память процесса, которая выдаётся нам по запросу (через new/malloc). Её гораздо больше, чем стековой (столько, сколько есть у всей системы). Обращение к ней происходит через указатели.

```cpp
type* p = new type();
```

Чтобы не происходило утечек памяти, динамическую память нужно освобождать (сама она освободиться не может). Делается с помощью delete/free.

**Утечка памяти** — это когда вы выделили динамическую память, но не вернули её системе по окончании её использования (или при каком-то аварийном завершении).

**Double deletion**

`delete` consist of 2 primary operations:

- it calls the destructor if it's defined
- it somehow frees the memory allocated to the object

If these deleted data are pointers then it will most likely segfault, because you will attempt to access memory  that contains something else, or doesn't belong to you.

## 8

**Область видимости** (scope) представляет часть программы, в пределах которой можно использовать объект. Как правило, **область видимости** ограничивается блоком кода, который заключается в фигурные скобки

Если в вашей программе находятся две переменные с одинаковым именем в одной области видимости, то будет CE.

Локальные переменные перекрывают менее локальные.

## 9

**Указатель** — переменная, значением которой является адрес ячейки памяти

Операции:

- разыменовывание - получить доступ к объекту по адресу указателя

- адреса указателей:

  ```cpp
  int a = 10;
  int *pa = &a;
  std::cout << "address of pointer=" << &pa << std::endl;        // адрес указателя
  std::cout << "address stored in pointer=" << pa << std::endl;  // адрес, который хранится в указателе - адрес переменной a         
  std::cout << "value on pointer=" << *pa << std::endl;          // значение по адресу в указателе - значение переменной a
  ```

- указатели можно сравнивать

- можно переназначать

- работает приведение типов

- void* - указатель на данные неизвестного типа, нельзя складывать с числами и вычитать друг из друга

  

**Массивы**

```cpp
int arr[4] = { 5, 8, 6, 4 };
// имеет тип int[4]
// переменная arr содержит адрес первого элемента массива
std::cout << *arr; // массив int[4] неявно конвертируется в указатель int*, разыменовываем указатель, который указывает на значение первого элемента массива

&arr[0];            /* address of first element */
&arr;            /* address of whole array */
```

**Различия:** sizeof(arr) = длина массива * размер элемента, sizeof(ptr) = 4

## 10

**Ссылка** — особый тип данных, который при использовании автоматически разыменовывается. Работает как псевдоним другого объекта или значения.

- Можно делать все то же, что и с объектом по ссылке

- Обязательно нужно инициализировать

- Нет арифметики ссылок, в отличие от указателей

- нельзя “перепривязать” ссылку к другому объекту

- No ref to ref

  ```cpp
  int a = 0;
  int& & b = a; // ban
  ```

```cpp
int foo(int& var) { 
	...
	return 0;
}

int foo1(int var) { 
	...
	return 0;
}

int var = 1;
foo(var); // передача по ссылке
foo1(var); // по значению (возникнет копия)

```

**Битая ссылка** — ситуация, когда используется ссылка на разрушенный объект. Использование такой ссылки является UB.

```cpp
int& foo() {
 int a = 4;
 return a;
}

int main() {
 int a = foo();
}
```

## 11

**Константы**  - переменные, к которым применимы только константные операции. Например, их, вообще говоря, нельзя менять.

**Константные методы** - методы класса, которые не вызывают неконстантные методы класса.

**Константные указатели и указатели на константы:**

```cpp
const int value = 7;
const int* ptr = &value; // pointer on const int
*ptr = 8; // CE
int *ptr = &value; // CE, cannot convert const int* to int*, а вот обратно можно

int value2 = 7;
int* const ptr = &value2; // const pointer on int - указатель, значение которого не может быть изменено после инициализации
*ptr = 8; // OK, value is not const
```

**Константная ссылка - ссылка на const value**

```cpp
const int value = 7;
const int &ref = value; // ref - это ссылка на константную переменную value
```

Ссылки на константные значения могут быть инициализированы const/(non const) l-values и r-values. 

При этом доступ к переменной из под ссылки считается доступом к константной переменной.

```cpp
int value = 7;
const int& ref = value
value = 8; // ок: value - это не константа
ref = 9; // нельзя: ref - это константа
```

## 13

**Перегрузка функций** — возможность создавать несколько одноименных функций, но с различными параметрами. Компилятор выбирает из них наиболее предпочтительные.

**Сигнатура функции** - типы аргументов, константность, виртуальность, имя и т.п.

**Процедура перегрузки**

- попытка найти точное совпадение
- promotion (int -> long long, float -> double)
- попытка найти совпадение путем неявного преобразования типов
- попытка найти совпадение путем пользовательских преобразований типов

- частное лучше общего (в вложенных областях видимости, например)

**Ambigious call**

```cpp
void f(int) {}
void f(float) {}
f(0.0); // ambigious
```

## 14

**Оператор** **точка:** обращение к методу объекта непосредственно через объект

**Оператор стрелка:** обращение к методу для указателя на объект ((*ob_ptrj).method)

**this** - скрытый указатель, содержащий адрес текущего объекта, вызывающий метод класса

Константные объекты класса могут вызывать только константные методы!

**Константный метод** — это метод, который гарантирует, что не будет изменять данные объекта или вызывать неконстантные методы класса  (поскольку они могут изменить объект).

## 15

**Конструктор** — это особый тип метода класса, который автоматически вызывается при создании объекта этого же класса. 

**Деструктор** — это специальный тип [**метода**](https://ravesli.com/urok-113-klassy-obekty-i-metody-klassov/) класса, который выполняется при удалении объекта класса.

В то время как [**конструкторы**](https://ravesli.com/urok-116-konstruktory/) предназначены для инициализации класса, деструкторы предназначены для очистки памяти после него.

Требуем наличие default конструктора:

- когда объект объявляется без аргументов
- в конструкторе потомка неявно вызывается default конструктор родителя (если в списке инициализации явно не указан какой-нибудь другой)

Требуем наличие copy конструктора:

- когда объект конструируется на основе другого объекта (того же класса)
- когда объект передается функции по значению в качестве аргумента

## 16

**Перегрузка операторов** — один из способов реализации полиморфизма, возможность одновременного существования в одной области видимости нескольких различных вариантов применения одинаковых по имени операторов, но различающихся типами операндов.

```cpp
class String {
public:
    String& operator=(const String& s) { 
        ...
        return *this;
    }
};
```

Вызывается, когда приравниваем один объект другому

## 17

- Конструктор по умолчанию генерируется автоматически, если нет объявленного пользователем конструктора (§12.1/5).
- Конструктор копирования автоматически генерируется, если нет объявленного пользователем конструктора перемещения или оператора присваивания перемещения
- Оператор назначения копирования генерируется автоматически, если нет объявленного пользователем конструктора перемещения или оператора назначения перемещения (§12.8/19).
- Деструктор генерируется автоматически, если нет объявленного пользователем деструктора (§12.4/4).

**Ключевое слово default**. Его использование указывает компилятору самостоятельно  генерировать соответствующую функцию класса, если таковая не объявлена в классе. 

**Ключевое слово delete** используется в случаях, когда нужно запретить автоматическое приведение типов в конструкторах и методах класса.

## 18

```cpp
class Values
{
private:
    const int m_value;
 
public:
    Values(): m_value(7) {}
};
// инициализация константы
```

Перед тем, как войти в тело конструктора, компилятор инициализирует поля (в т.ч. через списки инициализации). К моменту входа в конструктор все поля должны быть инициализированы.

*Инициализируйте переменные в списке инициализации в том порядке, в котором они объявлены в классе*

Известно, что ссылки нельзя переназначать. Поэтому их нужно инициализировать либо сразу же в теле класса, либо в списке инициализации в конструкторах. Ровно то же самое с константами.

## 19

**Наследование** — это одна из основных концепций ООП, позволяющая создавать классы на основе других классов, при этом заимствуя их функционал

Про приватное и публичное наследование см. в соответствующий пунктах intermediate.

## 20

```cpp
Derived d; // наследник Base
Base base = d; // инициализация объекта Base от объекта Derived
```

Здесь сработает slicing, т.е. возьмется часть Derived, отвечающая за Base и скопируется как новый объект класса Base.

В обратную сторону неявно это запрещено, т.е.

```cpp
Derived d2 = base; // CE
Base& base2 = d;
Derived& dd = base2; // CE
// и также с указателями
```

Но со static_cast можно, хотя и получим, вообще говоря, UB (если только под ссылкой не лежал настоящий наследник)

## 21

**Модификатор override** может использоваться с любым методом, который должен быть переопределением. Достаточно просто указать override в том месте, где обычно указывается const (после скобок с параметрами). Если метод не переопределяет виртуальную функцию родительского класса, то компилятор выдаст ошибку.

**final запрещает дальнейшее переопределение:**

```cpp
#include <iostream>
using namespace std;

struct A {
	virtual void funct() {}
};

struct B : A {
	void funct() final {}
};

struct C: B {
	void funct() {} // CE
};

int main() {
	// your code goes here
	return 0;
}
```

В случае, если мы хотим запретить наследование определенного класса, то модификатор
final указывается после имени класса.

## 22

*Инстанцирование шаблона* – это генерация кода функции или класса по шаблону для конкретных параметров.

## 23

Генерировать исключения - throw, обрабатывать - try/catch

**throw**

Тип выражения, указанного в операторе throw, определяет тип исключительной ситуации, а значение выражения может быть передано обработчику (catch). 

Блок кода, который потенциально выкидывает исключение, можно “обернуть” в try-блок,

который при возникновении исключения сообщит об этом catch-блоку, следующему сразу за try-блоком:

try {

 // код, бросающий исключение

} catch(/*тип исключения*/) {

 // обработка исключения

}

Последний, в свою очередь, проверяет исключение на соответствие (по типу), и, если нашёлся подходящий обработчик, исключение считается обработанным. Если же ни один из обработчиков не смог обработать исключение, оно пробрасывается дальше на более высокий уровень (т.е. программа как бы начинает “выходить” из вложенных блоков). После обработки исключения программа продолжит работу с кода, следующего после последнего catch-блока. Если исключение не было обработано на последнем (глобальном) уровне, то программа завершается с RE. 

## 24

![image-20210624221828928](/home/h4zzkr/snap/typora/39/.config/Typora/typora-user-images/image-20210624221828928.png)

## 26

**lower_bound:** Returns an iterator pointing to the first element that is *not less* than (i.e. greater or equal to) `key`.

**upper_bound:** Returns an iterator pointing to the first element that is *greater* than `key`.

## 27

![img](https://gblobscdn.gitbook.com/assets%2F-MSxndtKpQsQB7fGiRd4%2F-MU36dGYLoLSf25aJvid%2F-MU3sobM95Y5OJtzSw8w%2F%D0%A1%D0%BD%D0%B8%D0%BC%D0%BE%D0%BA%20%D1%8D%D0%BA%D1%80%D0%B0%D0%BD%D0%B0%20%D0%BE%D1%82%202021-02-21%2016-58-51.png?alt=media&token=f088e4d6-2d35-4a68-9783-b26743d6f5ab)

**Forward Iterator:** однонаправленные итераторы,могут перемещаться только в одну сторо-
ну на 1 позицию, перемещение в обратную сторону занимает продолжительное время.
Позволяет инкрементировать себя, при этом операция += 1 не определена. Пример:
вспомнить после какой строки в стихотворении идет определенная строка;

**Bidirectional Iterator:** двунаправленные итераторы, могут быстро перемещаться на одну
позицию как вперед, так и назад. Позволяет не только инкрементировать, но и декре-
ментировать себя - при этом операция += 1 не определена; Пример: станции до и после
Новодачной

**Random-access:** итераторы: могут перемещаться быстро на любую позицию в контейнере.
Позволяет прибавлять и вычитать из себя любые числа, вычитать два итератора друг
из друга и сравнивать на меньше, больше.

## 30

**Мотивировка**

```cpp
v.push_back(std::string("abc"));

void push_back(const T& val) {
    if (sz == cap) reserve(2 * cap); // расширить
    AllocTraits::construct(alloc, arr + sz, value); // сконструировать по адресу arr + sz.
}
```

В construct будет лишняя копия val. Хотя объект val нам уже не понадобиться. Ссылкой тоже нельзя, объект временный и помрет при выходе.

При реаллокации тоже лишние копии. 

```cpp
f(createHeavyObject()); // в f чтобы избежать лишней копии, нужно принимать по конст ссылке, но тогда не сможем менять объект
```

Move-семантика позволяет избежать этого для ваших классовых типов.

**std::move, std::forward, правило пяти**

```cpp
class String {
    char* str = nullptr;
    size_t sz = 0;
    
    String(String&& s): sz(s.sz), str(s.str) {
        // str = s.str; // нельзя в copy constructor (двойное удаление)
        s.str = nullptr;
        s.sz = 0;
    }
    
    void swap(String& s) {
        std::swap(sz, s.sz);
        std::swap(str, s.str);
    }
    
    String& operator=(String&& s) {
        String new_s = std::move(s); // вызов move-конструктора
        swap(new_s);
        return *this;
    }
    
};
```

```cpp
void push_back(T&& value) {
    AllocTraits::construct(alloc, arr + sz, std::move(value));
    ++sz;
}
```

# 